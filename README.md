## 项目介绍：
Ucore是一个实验性质的基于X86指令集架构的操作系统内核代码。<br>
Ucore是基于MIT的xv6的设计，一步一步完成从一个空空如也到五脏俱全的“麻雀”操作系统。<br>
此“麻雀”包括虚存管理、进程管理、处理器调度、同步互斥、进程间通信等主要内核功能，总的内核代码量（c+asm）不超过5K行，充分体现了小而全的思想。<br>

## 项目收获：
通过Ucore项目，能对操作系统的原理有了更深入的理解，包括从CPU上电开始，通过BootLoader程序为操作系统准备好起始的运行环境，再将UcoreOS内核加载到内存中，权限转交给操作系统，操作系统依次执行各个子系统的初始化工作，整个流程在脑海中有了清晰认识，对操作系统的理解形成了一个体系而不再是分散的知识点。并且对于以下概念有了更深入的理解：<br>
● 为什么堆上内存会发生泄露？<br>
● 用户态和内核态是什么，如何从用户态切换到内核态？<br>
● 零拷贝技术是什么？为什么传统网络内核协议栈处理速度较慢？<br>
● 怎么通过fork复制出一个进程？怎么通过exec加载一个用户程序创建一个用户进程？<br>
● 段页式映射机制是怎么工作的？<br>
● 虚存管理是如何给用户程序提供了一个磁盘大小的内存空间的假象？<br>
● 函数调用怎么创建栈帧？<br>
● ......<br>



## 个人职责和项目实现内容
Ucore本身包括操作系统内核的框架代码，个人需要阅读弄清楚Ucore的框架代码，在此基础上为每个模块实现关键部分代码，具体如下：<br>
● 创建Page结构体管理物理页，实现first-fit连续物理内存分配算法<br>
● 实现根据虚拟地址寻找对应的页表项，以及释放虚地址所在的页并取消对应二级页表项的映射<br>
● 补充完成基于FIFO的页面替换算法，实现缺页异常处理<br>
● 设计实现进程控制块，实现alloc_proc函数分配并初始化一个进程控制块<br>
● 实现do_fork函数调用，为新创建的线程分配资源，实现进程地空间的拷贝<br>
● 实现do_execv函数调用，加载并解析一个处于内存中的ELF执行文件的应用程序，创建用户进程<br>
● 补充完成Round Robin进程调度算法，补充完成进程间同步互斥的信号量机制<br>
● 完善中断初始化和处理，对中断描述符表的初始化工作<br>

## 项目结构介绍
/boot：操作系统的bootloader程序的实现，主要负责为操作系统建立好相应的环境(开启保护模式、初始化段表、设置C语言运行的栈寄存器、探测物理内存)，读取磁盘第一个扇区将ucore的elf格式文件加载到内存，将权限交给OS。<br>
/kern：包含Ucore的主要内核代码，包含各个内核子模块的实现。<br>
/kern/init: 包含Ucore的起始入口地址，调用其他内核子模块完成整个ucore操作系统的初始化。<br>
/kern/mm: 主要包含UCore的内存管理的内核代码，包括物理内存和虚存的管理，建立页式映射机制、实现物理页的换入换出策略。<br>
/kern/process: 进程管理的相关代码，包括进程控制块结构体、进程的复制fork、用户进程创建execv等实现。<br>
/kern/schedule: 进程调度的相关代码，实现round-robin调度算法。<br>
/kern/sync: 主要包含进程同步互斥的相关代码，包括信号量semphore机制的实现。<br>
/kern/trap: 中断和异常处理的相关代码，定义中断描述符表以及每个中断处理程序的地址，负责处理ucore运行过程中遇到的中断和异常。
